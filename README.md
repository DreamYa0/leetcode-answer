# 滑动窗口

## 固定长度滑窗模版

题目一般会给你一个k区间，然后求k区间内的某种结果

```rust
    // 一般先处理 0到k 的第一个窗口结果
    for i in 0..k as usize {
        
    }
    
    // 滑动窗口处理后续 k到nums.len() 元素
    for i in k as usize..nums.len() {
        
    }
```

## 最小滑窗模板

给定数组 nums，定义滑窗的左右边界 i, j，求满足某个条件的滑窗的最小长度。

```python
while j < len(nums):
    判断[i, j]是否满足条件
    while 满足条件：
        不断更新结果(注意在while内更新！)
        i += 1 （最大程度的压缩i，使得滑窗尽可能的小）
    j += 1
```

## 最大滑窗模板

给定数组 nums，定义滑窗的左右边界 i, j，求满足某个条件的滑窗的最大长度。

```python
while j < len(nums):
    判断[i, j]是否满足条件
    while 不满足条件：
        i += 1 （最保守的压缩i，一旦满足条件了就退出压缩i的过程，使得滑窗尽可能的大）
    不断更新结果（注意在while外更新！）
    j += 1
```

最小滑窗和最大滑窗，关键的区别在于，最大滑窗是在迭代右移右边界的过程中更新结果，而最小滑窗是在迭代右移左边界的过程中更新结果。因此虽然都是滑窗，但是两者的模板和对应的贪心思路并不一样，而真正理解后就可以在lc.76，lc.904，lc.3, lc.1004写出非常无脑的代码。

# 分组循环

适用场景：按照题目要求，数组会被分割成若干组，且每一组的判断/处理逻辑是一样的。

## 核心思想：

- 外层循环负责遍历组之前的准备工作（记录开始位置），和遍历组之后的统计工作（更新答案最大值）。

- 内层循环负责遍历组，找出这一组最远在哪结束。

这个写法的好处是，各个逻辑块分工明确，也不需要特判最后一组（易错点）。以我的经验，这个写法是所有写法中最不容易出 bug 的，推荐大家记住。

## 复杂度分析

- 时间复杂度：O(n)，其中 n 为 nums 的长度。时间复杂度乍一看是 O(n^2)，但注意变量 i 只会增加，不会重置也不会减少。所以二重循环总共循环 O(n) 次，所以时间复杂度是 O(n)。

- 空间复杂度：O(1)。仅用到若干额外变量。

## 分组循环模版

```python
n = len(nums)
i = 0
while i < n:
    start = i
    while i < n and ...:
        i += 1
    # 从 start 到 i-1 是一组
    # 下一组从 i 开始，无需 i += 1
```

# 前缀和